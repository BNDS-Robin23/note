# 程序的转换与机器级表示
## 程序转换
高级语言程序-->预处理-->编译，生成汇编语言程序-->汇编，生成可重定位的机器语言目标代码文件-->链接，生成最终的可执行文件

## IA-32指令集
### IA-32的寄存器组织结构
+ 8个通用寄存器： EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI
  + 对于通用寄存器，每个都是32位的。
  + 以EAX举例，AX表示EAX的末16位，AH, AL分别表示AX的高八位和末八位。
  + |-------------------------------|EAX|-----AH-----|AX|-----AL------|
+ 2个专用寄存器： EIP,EFLAGS
  + EFLAGS用于存储运算是否正确的指示结果
+ 6个段寄存器： CS,SS,DS,ES,FS,GS
  + CS:代码段
  + SS:堆栈段
  + DS:数据段
  + ES:附加段
  + FS:附加段
  + GS:附加段

### IA-32的标志寄存器EFLAGS
|31-32|21|20|19|18|17|16|15|14|13 12|11|10|9|8|7|6|5|4|3|2|1|0|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|保留|ID|VIP|VIF|AC|VM|RF|0|NT|TOPL|0|D|I|T|S|Z|0|A|0|P|1|C|
### IA-32的寻址方式
+ 寻址方式
  + 根据指令的信息得到操作数或操作数地址
+ 操作数所在位置
  + 指令中: 立即寻址
  + 寄存器中： 寄存器寻址
  + 存储单元中： 属于（存储器操作数，按字节编址）：其他寻址方式，如下
+ 存储器操作数的寻址方式有以下两种模式
  + 实地址模式（物理层面考虑，现在实际上已经用不到了）
    + 为与8086/8088兼容而设置，或者是电脑加电或复位时。
    + 寻址空间为20位地址。1MB
  + **保护模式**
    + 加电后进入，采用内存虚拟存储管理，多任务状态下隔离、保护不同程序之间的数据栈。
    + 寻址空间为32位地址，4GB.32位地址分段（段基址+段内偏移量）

### 保护模式下的寻址方式
|寻址方式|说明|
|:------:|:------:|
|立即寻址|指令直接给出操作数|
|寄存器寻址|指定的寄存器R的内容即为操作数|
|位移寻址|LA=(SR)+A|
|基址寻址|LA=(SR)+(B)|
|基址加位移|LA=(SR)+(B)+A|
|比例变址加位移|LA=(SR)+(I)*S+A|
|基址加变址加位移|LA=(SR)+(B)+(I)+A|
|基址加比例变址加位移|LA=(SR)+(B)+(I)*S+A|
|相对寻址|LA=(PC)+A|

注：LA: 线性地址，(X): X的内容 SR: 段寄存器 PC: 程序计数器 R: 寄存器 A: 指令中给定的地址段的偏移量 B: 基址寄存器 I: 变址寄存器 S: 比例系数  
+ SR段寄存器（间接）确定操作数所在段的段基址
+ 有效地址给出操作数在所在段的偏移地址

+ 例子
  ```
  int x;
  float a[100];
  short b[4][4];
  char c;
  double d[10];
  ```
  设x的地址为100-103.（位移/基址）
  + a[i]的地址为104+i*4，比例变址+位移
  + b[i][j]的地址为504+i*8+j*2，基址+比例变址+位移
  + d[i]地址为544+i*8，比例变址+位移

### IA-32常用指令类型
+ 传送指令
  + 通用数据传送指令
    + MOV:数据传送
    + MOVS:符号扩展传送
    + MOVZ：零扩展传送
    + XCHG：数据交换
    + PUSH/POP：入栈出栈
  + 地址传送指令
    + LEA:加载有效地址
  + 输入输出指令
    + IN,OUT
  + 标志传送指令
    + PUSHF,POPF：将EFLAG压栈，或将栈顶内容送到EFLAG
+ 定点算术指令
  + 加减
  + 增1减1
  + 取负
  + 比较
  + 乘除
    + MUL/IMUL
    + DIV/IDIV
+ 按位运算指令
+ 控制转移指令
