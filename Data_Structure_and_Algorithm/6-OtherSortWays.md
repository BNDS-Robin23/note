# 算法复杂性分析和不基于比较的排序算法
## 算法复杂性分析
+ 一个算法给出的是解决某个问题的上界
+ 解决问题的复杂性下界由该问题本身去定义
+ 证明算法复杂性的下界往往很难，因为需要证明对于任何算法，其复杂性都大于这个值

## 证明下界的算法
+ The Adversary Argument对手论证
  + 构造多个输入的情况，使得他们在任一算法的query下给出的answer都相同，但是这些多个输入至少有一个在该算法的作用下不能得到正确的结果。
+ 决策树算法。每一次query都相当于进行一次决策，而决策树的最小高度，即作出觉得所需要的最小步骤，就是最低复杂度

## 基于比较的排序算法
$任何基于比较的排序算法，其复杂度均为\Omega (n\lg n)$  
下面使用决策树方法证明：  
+ 不失一般性，假设所有的输入元素都不相同
+ 假设算法仅使用小于等于号来进行比较
+ 显然，决策树的叶节点总数至少有$n!$（即所有元素的全排列）个
+ 因此，至少需要$\Omega(\lg n!)=\Omega(n\lg n)$

## 不基于比较的排序算法
### 桶排序
+ 并不是基于比较的排序，而是利用这些数本来的性质、值来操作
+ 更进一步，可以分出k个桶，每个桶覆盖原来范围的d/k的区间，然后在桶内调用已有的排序方法来进行排序。
  
### 基数排序
+ 从最低位开始，用稳定排序对数组的每一个数进行排序。